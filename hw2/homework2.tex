
\documentclass{article}

\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{latexsym,amsthm,amssymb,amscd,url,enumerate}
\usepackage[show]{ed}
\usepackage[all]{xy}
\usepackage{tikz}
\usepackage{tikz-cd}
\usepackage{leftidx}
\usetikzlibrary{arrows}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{proof}
\usepackage{hyperref}
\usepackage{framed}
\usepackage{fullpage}

\newtheorem{theorem}{Theorem}						
\newtheorem{definition}[theorem]{Definition}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{axiom}{Axiom}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{corollary}[theorem]{Corollary}

%% ==================================================================
%% MACROS
%% ==================================================================

\newcommand{\E}{\mathtt{E}}
\newcommand{\B}{\mathtt{B}}
\newcommand{\C}{\mathtt{C}}
\newcommand{\R}{\mathtt{R}}
\newcommand{\N}{\mathtt{N}}
\newcommand{\LL}{\mathtt{L}}
\newcommand{\true}{\mathtt{true}}
\newcommand{\false}{\mathtt{false}}
\newcommand{\andsym}{\mathtt{and}}
\newcommand{\orsym}{\mathtt{or}}
\newcommand{\notsym}{\mathop{\mathtt{not}}}
\newcommand{\ifsym}{\mathtt{if}}
\newcommand{\then}{\mathtt{then}}
\newcommand{\elsesym}{\mathtt{else}}
\newcommand{\whilesym}{\mathtt{while}}
\newcommand{\dosym}{\mathtt{do}}
\newcommand{\skipsym}{\mathtt{skip}}
\newcommand{\nil}{\mathtt{nil}}
\newcommand{\case}{\mathtt{case}}
\newcommand{\digit}{\mathtt{d}}
\newcommand{\negation}{\mathtt{neg}}
\newcommand{\Digit}{\mathbf{Digit}}
\newcommand{\denot}[1]{\mathtt{[[{#1}]]}}
\newcommand{\Sem}{\mathtt{S}}

\newcommand{\G}{\Gamma}
\newcommand{\D}{\Delta}

\newcommand{\type}{\;\mathsf{type}}
\newcommand{\val}{\;\mathsf{val}}
\newcommand{\dom}[1]{\mathsf{dom}(#1)}
\newcommand{\FV}{\mathsf{FV}}
\newcommand{\reduces}{\mapsto}

\newcommand{\ctx}[3]{(#1,#2\rhd #3)}
\newcommand{\bool}{\mathbf{2}}
\newcommand{\boolt}{\mathsf{tt}}
\newcommand{\boolf}{\mathsf{ff}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}

% Logical equivalence
\newcommand{\rels}[3]{#1:#2\leftrightarrow #3}
\newcommand{\relto}{\hookrightarrow}
\newcommand{\LR}[2]{\sem{#1}_{#2}}

\newcommand{\gd}[1]{\hat\gamma(\hat\delta(#1))}
\newcommand{\gdp}[1]{\widehat{\gamma'}(\widehat{\delta'}(#1))}

% Existential types
\newcommand{\pack}[3]{\mathsf{pack}\,#1\,\mathsf{with}\,#2\,\mathsf{as}\,#3}
\newcommand{\open}[4]{\mathsf{open}\,#1\,\mathsf{as}\,#2\,\mathsf{with}\,#3\,\mathsf{in}\,#4}

% Data types
\newcommand{\Nat}{\mathsf{nat}}
\newcommand{\z}{\mathsf{z}}
\newcommand{\suc}{\mathsf{suc}}
\newcommand{\natrec}{\mathsf{natrec}}
\newcommand{\pred}{\mathsf{pred}}
\newcommand{\sub}{\mathsf{sub}}

\newcommand{\List}{\mathsf{list}}
\newcommand{\cons}{\mathsf{cons}}
\newcommand{\foldr}{\mathsf{foldr}}

\newcommand{\fst}{\mathsf{fst}}
\newcommand{\snd}{\mathsf{snd}}

\newcommand{\oList}{\overline{\mathsf{list}}}
\newcommand{\onil}{\overline{\mathsf{nil}}}
\newcommand{\ocons}{\overline{\mathsf{cons}}}
\newcommand{\ohead}{\overline{\mathsf{head}}}
\newcommand{\otail}{\overline{\mathsf{tail}}}
\newcommand{\ofoldr}{\overline{\mathsf{foldr}}}

% crazy hacks
\makeatletter
\def\lam#1{{\lambda}\@lamarg#1:\@endlamarg\@ifnextchar\bgroup{.\,\lam}{.\,}}
\def\@lamarg#1:#2\@endlamarg{\if\relax\detokenize{#2}\relax #1\else\@lamvar{\@lameatcolon#2},#1\@endlamvar\fi}
\def\@lamvar#1,#2\@endlamvar{#2\,{:}\,#1}
\def\@lameatcolon#1:{#1}
\let\lamt\lam
\makeatother

% disable hbox warnings
\hfuzz=5.002pt 

%% ==================================================================
%% HELPERS
%% ==================================================================

\definecolor{DarkBlue}{rgb}{0.00,0.30,0.90}

\newcommand{\question}[1]
{\color{DarkBlue}#1 \color{Black}}

\definecolor{comment-color}{rgb}{1,0,0}
\renewcommand{\todo}[1]{
\textnormal{\color{comment-color}{\textbf{TODO: #1}}}\unskip}

%% ==================================================================
%% DOCUMENT
%% ==================================================================

\begin{document}

\title{\textbf{15-812 Semantics of Programming Languages \\ Spring 2015 \\
{\large Assignment 2 Solutions}}\\\vspace{0.3in}
{\Large \bf Joy Arulraj (AID : jarulraj)}}

\date{}
\author{}

\maketitle

\question{
\noindent In this assignment we will revisit the imperative language $\mathcal{L}$ defined by the syntax
\begin{align*}
& \E := \mathtt{n} \; | \; \mathtt{x} \; | \; \E_1 + \E_2 \; | \; \E_1 \cdot \E_2 \; | \; \negation(\E) \; | \; \ifsym \; \B \; \then \; \E_1 \; \elsesym \; \E_2 \\ 
& \B := \true \; | \; \false \; | \; \B_1 \; \andsym \; \B_2 \; | \; \B_1 \; \orsym \; \B_2 \; | \; \notsym \; \B \; | \; \E_1 \leq \E_2 \\
& \C := \skipsym \; | \; \mathtt{x} := \E \; | \; \C_1 ; \C_2 \; | \; \ifsym \; \B \; \then \; \C_1 \; \elsesym \; \C_2 \; | \; \whilesym \; \B \; \dosym \; \C
\end{align*}
and the state-transition $[[\cdot]]$, input/output $\mathcal{I}$, and termination $\mathcal{T}$ semantics for $\mathcal{L}$ as defined in class. Recall that two programs $\C_1, \C_2$ are 

\begin{enumerate}

\item \emph{equivalent} with respect to a semantics $\Sem$ 
if $\Sem(\C_1) = \Sem(\C_2)$
\item \emph{contextually equivalent} with respect to $\Sem$ 
if $\forall \mathcal{C}, \Sem(\mathcal{C}[\C_1]) = \Sem(\mathcal{C}[\C_2])$, where $\mathcal{C}$ ranges over program contexts

\end{enumerate}

For two semantics $\Sem_1, \Sem_2$ we say that
\begin{enumerate}
	\item $\Sem_1$ is \emph{compositional} with respect to $\Sem_2$ if for any two programs $\C_1,\C_2$, 
	we have that $\Sem_1(\C_1) = \Sem_1(\C_2)$ implies $\forall \mathcal{C}, \Sem_2(\mathcal{C}[\C_1]) = \Sem_2(\mathcal{C}[\C_2])$

	\item $\Sem_1$ is \emph{fully abstract} with respect to $\Sem_2$ if for any two programs $\C_1,\C_2$, 
	we have that $\forall \mathcal{C}, \Sem_2(\mathcal{C}[\C_1]) = \Sem_2(\mathcal{C}[\C_2])$ implies $\Sem_1(\C_1) = \Sem_1(\C_2)$
	\end{enumerate}
	A semantics $\Sem$ is \emph{compositional} if it is compositional with respect to itself.\bigskip

\noindent \textbf{Please justify all answers.}
}

%% ==================================================================
%% REVISITING SEMANTICS
%% ==================================================================

\section{Revisiting semantics}

\begin{enumerate}
\question{
\item[1.1] 
\begin{enumerate}
	\item[a)] Is the input/output semantics $\mathcal{I}$ compositional? Is it
	fully abstract with respect to the termination semantics $\mathcal{T}$?
	\item[b)] Is the termination semantics $\mathcal{T}$ compositional? Is it
	fully abstract with respect to the input/output semantics $\mathcal{I}$?
\end{enumerate}
}

(a) \begin{itemize}

\item \textbf{Compositionality property :}

	Yes, $\mathcal{I}$ is compositional. 
		
	By definition, 
	$\mathcal{I} : \textbf{Com} \rightarrow (St \rightarrow St_{ \bot })$
	$ \mathcal{I}(c) = | c | \cup  \{ (\sigma, \bot) \; | \; \sigma
	\notin dom | c | \} $
		
	For any two programs, $\C_1,\C_2$, if we have that $\mathcal{I}(\C_1) =
	\mathcal{I}(\C_2)$, 
	then this implies that $|\C_1| = | \C_2|$. This directly follows from the definition.
	Thus, input/output semantics and state transformation semantics are
	equipollent.
	
	For all contexts $\mathcal{C}, \; \mathcal{I}(\mathcal{C}[\C_1]) =	
	\mathcal{I}(\mathcal{C}[\C_2])$. This follows from the compositionality of the
	state transformation semantics. Hence, $\mathcal{I}$ is compositional. 

\item \textbf{$\mathcal{I}$ is fully abstract with respect to the termination
semantics $\mathcal{T}$}

	Yes, $\mathcal{I}$ is fully abstract with respect to the termination
	semantics $\mathcal{T}$.
	To show this, we consider any two programs $\C_1,\C_2$.
	We have that $\forall \mathcal{C},	
	\mathcal{T}(\mathcal{C}[\C_1]) = \mathcal{T}(\mathcal{C}[\C_2])$.	
 	
 	We first show that contextual equivalence with respect to $\mathcal{I}$ is 
 	the same as contextual equivalence with respect to $\mathcal{T}$.
	We show this using a contrapositive example comprising of a set of commands
	$\C_1$ and $\C_2$, where $\mathcal{I}(\C_1) Ì¸\neq \mathcal{I}(\C_2)$.
	Here, we argue that there exists a context $C$ in which 
	$\mathcal{T}(C [\C_1 ]) \neq \mathcal{T}(C [\C_2 ])$.
	Consider a state transition $(\sigma,\tau) \in \mathcal(\C_1)$ and
	that $(\sigma,\tau) \notin \mathcal(\C_2)$.
	Let the $dom(\tau)$ comprise of $x_{l}$ and let $\tau(x_{l}) = v_{l}$. 
	Let $b$ be the boolean expression $x_{l} \neq v_{l}$.

	Now, consider the context $C = [ \_ ];$ $\ifsym$ b $ \then \; \skipsym \;
	\elsesym \; \whilesym \; \true \; \dosym \; \skipsym$. Clearly, executing
	$C[\C_1]$ from $\sigma$ terminates, but executing $C[\C_2]$ from $\sigma$ does not terminate. Thus, 
	contextual equivalence with respect to $\mathcal{I}$ is the same as 
	contextual equivalence with respect to $\mathcal{T}$.
    We already showed that input/output semantics and state transformation
    semantics are equipollent.
    This implies that if $\forall \mathcal{C},
    \mathcal{T}(\mathcal{C}[\C_1]) = \mathcal{T}(\mathcal{C}[\C_2])$, 
    then $| \C_1 | = | \C_2 |$. As, $\mathcal{I}$ and $|.|$ are equipollent,
	$\mathcal{I}(\C_1) = \mathcal{I}(\C_2)$
	
\end{itemize}

(b) \begin{itemize}

\item \textbf{Compositionality property :}

	No, $\mathcal{T}$ is not compositional.

	For any two programs, $\C_1,\C_2$, if $\mathcal{T}$ is compositional,
	then : if we have that $\mathcal{T}(\C_1) = \mathcal{T}(\C_2)$, then 
	this implies that for all contexts $\mathcal{C}, \;
	\mathcal{T}(\mathcal{C}[\C_1]) = \mathcal{T}(\mathcal{C}[\C_2])$.
	However, we give a counterexample.
		
	Consider the programs $\C_1 = (x = 1;)$ and $\C_2 = (x = 2;)$.
	Clearly, $\mathcal{T}(\C_1) = \mathcal{T}(\C_2)$.
	However, consider the context $C = [ \_ ];$ $\ifsym \; x = 1 \; \then \;
	\skipsym \; \elsesym \; \whilesym \; \true \; \dosym \; \skipsym$.
	In this case,  $\mathcal{T}(\mathcal{C}[\C_1]) \neq \mathcal{T}(\mathcal{C}
	[\C_2])$, because it terminates in the former case but not in the later
	case. Hence, $\mathcal{T}$ is not compositional. 

\item \textbf{$\mathcal{T}$ is fully abstract with respect to the termination
semantics $\mathcal{I}$}

	Yes, $\mathcal{T}$ is fully abstract with respect to the termination
	semantics $\mathcal{I}$.
	To show this, we consider any two programs $\C_1,\C_2$.
	We have that $\forall \mathcal{C},	
	\mathcal{I}(\mathcal{C}[\C_1]) = \mathcal{I}(\mathcal{C}[\C_2])$.	
 	
	We showed in the previous sub-problem that contextual equivalence with respect
	to $\mathcal{I}$ is the same as contextual equivalence with respect to 
	$\mathcal{T}$. Furtner, we proved that input/output semantics and state
	transformation semantics are equipollent.
	This implies that if $\forall \mathcal{C},
    \mathcal{I}(\mathcal{C}[\C_1]) = \mathcal{I}(\mathcal{C}[\C_2])$, 
    then $| \C_1 | = | \C_2 |$ and therefore $\mathcal{T}(\mathcal{C}\C_1) =
    \mathcal{T}(\mathcal{C}\C_2)$. 
    For the identity context $\mathcal{C} = [ \_ ];$,
    $\mathcal{T}(\C_1) = \mathcal{T}(\C_2)$. 
    Thus,  $\mathcal{T}$ is fully abstract with respect to the termination
	semantics $\mathcal{I}$.
	
\end{itemize}

\question{	
\item[1.2]
\begin{enumerate}
	\item[a)] Give a semantics $\Sem$ such that the state transition semantics 
	$[[\cdot]]$ is not compositional with respect to $\Sem$.
	\item[b)] Give a semantics $\Sem$ such that the state transition semantics 
	$[[\cdot]]$ is not fully abstract with respect to $\Sem$.
\end{enumerate}
}

(a) Consider the semantics $\mathcal{DEPTH}$, defined thus :

	$\mathcal{DEPTH} : \textbf{Com} \rightarrow (St \rightarrow St)$
	
	$ \mathcal{DEPTH}(c) = \{ (\sigma, [ \sigma | x : length(c) ] ) 
	\; | \; x \in dom (\sigma) \}$,
	
	where the function depth is defined thus :
	$depth$ : $\textbf{Com} \rightarrow \N$ 	
	\begin{align*}
	& depth(\skipsym) = 0 \\
	& depth(x := e) = 1 + depth(e) \\
	& depth (\C_1 ; \C_2 ) = 1 + max (depth (\C_1 ), depth (\C_2 ))	\\
	& depth(\ifsym \; b \;  \then \;  \C_1 \;  \elsesym \;  \C_2 ) 
	= 1 + max(depth(b), depth(\C_1), depth(\C_2)) \\
	& depth (\whilesym \; b \;  \dosym \;  \C) = 1 + max (depth (b), depth (\C)) \\
	\end{align*}
	
	Now, consider the commands $\C_1 = (x = 1;)$ and $\C_2 = (x = 1; x = 2;)$.
	By definition of the state transition semantics, we observe that 
	$[[ \C_1 ]] = [[ \C_2 ]] $. Intuitively, they both transition from the
	initial state $\sigma$  to a state, where if x $\in dom(\sigma)$, then $x = 2$.
	Now, we note that $\mathcal{DEPTH}(\C_1) = 1$ and $\mathcal{DEPTH}(\C_2) = 2$. 
	
	Thus, $[[ \C_1 ]] = [[ \C_2 ]]$ does \textit{not} imply
	$\mathcal{DEPTH}(\mathcal{C}[\C_1]) = \mathcal{DEPTH}(\mathcal{C}[\C_2])$ 
	for the identity context $\mathcal{C} = [\_];$.
	Hence, $[[\cdot]]$ is not compositional with respect to $\mathcal{DEPTH}$.	
 

(b) Consider the semantics $\mathcal{HITCHHIKER}$, defined thus :

	$ \mathcal{HITCHHIKER}(c) = \{ (\sigma, [ \sigma | x : 42 ] ) 
	\; | \; x \in dom (\sigma) \}$.
	
	Now, consider two programs $\C_1$ and $\C_2$ such that 	$[[ \C_1 ]] \neq [[
	\C_2 ]]$. Let the initial state $\sigma \in dom(\C_1)$ and  $\sigma \in
	dom(\C_2)$.
	
	$\forall \mathcal{C}$, we note that $\mathcal{HITCHHIKER}(\mathcal{C}[\C_1]) =
	\mathcal{HITCHHIKER}(\mathcal{C}[\C_2])$.
    This is because, they both transition from the initial state $\sigma$
    to a state, where if x $\in dom(\sigma)$, then $x = 42$.  
    However, we know that $[[ \C_1 ]] \neq [[ \C_2 ]]$.
    Hence, $[[\cdot]]$ is not fully abstract with respect to
    $\mathcal{HITCHHIKER}$.
            
\question{
\item[1.3] In the previous homework assignment, question 2, you defined a denotational 
semantics $\Sem$ for the extended imperative language $\mathcal{L}_e$:

\begin{align*}
& \E := \mathtt{n} \; | \; \mathtt{x} \; | \; \E_1 + \E_2 \; | \; \E_1 \cdot \E_2 \; | \; \negation(\E) \; | \; \ifsym \; \B \; \then \; \E_1 \; \elsesym \; \E_2 \\ 
& \B := \true \; | \; \false \; | \; \B_1 \; \andsym \; \B_2 \; | \; \B_1 \; \orsym \; \B_2 \; | \; \notsym \; \B \; | \; \E_1 \leq \E_2 \\
& {\color{red} \LL := \nil \; | \; (\mathtt{n},\C)::\LL} \\
& \C := \skipsym \; | \; \mathtt{x} := \E \; | \; \C_1 ; \C_2 \; | \; \ifsym \; \B \; \then \; \C_1 \; \elsesym \; \C_2 \; | \; \whilesym \; \B \; \dosym \; \C \; | \; {\color{red} \case \; \E \; \LL \; \C}
\end{align*}

Is $\Sem$ compositional? 
Is the state transition semantics $[[\cdot]]$ compositional with respect to $\Sem$? 
Is it fully abstract?
}

The semantic function S : St $\rightarrow$ St is given by :
\begin{align*}
& S( \; skip \; ) \; = \; \{ (\sigma, \sigma) \; | \; \sigma \in St \} \\
& S( \; x := e \; ) \; = \; \{ (\sigma, [\sigma | x : v]) \; | \; (\sigma, v)
\in | e | \; \& \; x \in dom(\sigma) \} \\
& S( \; \C_1 ; \C_2 ) \;  = \; \{ (\sigma, \sigma'') \; | \; \exists
\sigma'.(\sigma, \sigma') \in | \C_1 | \; \&  \; (\sigma',\sigma'') \in | \C_2 | \} 
\; = \; | \C_2 | \circ | \C_1 | \\
& S( \; \ifsym \; b \; \then  \; \C_1 \; \elsesym \; \C_2 \; ) \; = \; | \;
\C_1 | \; \circ  \; | b |_{\true} \; \cup \; |\C_2| \; \circ \; | b |_{\false} \\
& S( \; \whilesym \; b \; \dosym \; \C \; ) \; = \; | b |_{\false} \; \circ \;
(|c| \; \circ \; | b |_{true} )^{*} \\
& S( \; \case \; \E \; \LL \; \C \; ) \; = \C \; \circ \; | |\E| \in
dom(\LL) ) |_{\false} \cup \; \LL(|\E|) \; \circ \; | |\E| \in dom(L) |_{\true} 
\end{align*}

We note that if $S( \C_1 ) = S( \C_2 )$, then $\forall \mathcal{C}$, $S(
\mathcal{C}[\C_1] ) = S( \mathcal{C}[\C_2] )$. This is because 
each of these semantic clauses define the meaning of a compound phrase 
from the meanings of its parts. Thus, these transition rules uniquely determine
the semantic function on all expression arguments. Hence, it is
compositional with respect to itself.

Next, we observe that for all commands $\C_1$ and $\C_2$, $| \C_1 | = | \C_2 |$
if and only if $S( \C_1 ) = S( \C_2 )$. In other words, the state transition semantics
and S are equipollent. Hence, the state transition semantics $[[\cdot]]$
is compositional with respect to $S$.

Finally, if $\forall \mathcal{C}$, $S(\mathcal{C}[\C_1] ) = S( \mathcal{C}[\C_2]
)$, then for the identity context $\mathcal{C} = [\;\_\;]; $, 
$ S(\C_1) = S(\C_2)$. Hence, it is fully abstract with respect to itself.
We note that by the compositionality property of the state transition semantics
$[[\cdot]]$, if $\forall \mathcal{C}$, $| \mathcal{C}[\C_1] | = |
\mathcal{C}[\C_2] |$, then $S(\C_1) = S(\C_2) $.
Therefore, $S$ is fully abstract with respect to the state transition semantics
$[[\cdot]]$.

\end{enumerate}


%% ==================================================================
%% IMPERATIVE REASONING
%% ==================================================================

\section{Imperative reasoning}
\begin{enumerate}

\question{
\item[2.1] Prove or disprove the following statements.
\begin{enumerate}
\item[a)] The programs $(\whilesym\; \B \; \dosym \; \C); (\ifsym \; \B \; \then \; \C_1 \; \elsesym \; \C_2)$ and $(\whilesym \; \B \; \dosym \; \C);\C_2$
are equivalent with respect to the state transition semantics $[[\cdot]]$.

\item[b)] The programs $\whilesym\; \B \; \dosym \; \C$ and $\whilesym \; \B \; \dosym \; (\C;\ifsym \; \B \; \then \; \C \; \elsesym \; \skipsym)$ are 
equivalent with respect to the state transition semantics $[[\cdot]]$.

\item[c)] The programs $\whilesym\; \B \; \dosym \; (\whilesym \; \B \; \dosym \; \C)$ and $\whilesym\; \B \; \dosym \; \C$ are 
contextually equivalent with respect to the state transition semantics $[[\cdot]]$.
\end{enumerate}
}

\question{
\item[2.2] Under what conditions are the programs
\begin{enumerate} 

\item[a)] $\C;(\ifsym \; \B \; \then\; \C_1\; \elsesym \; \C_2)$ and $\ifsym \; \B \; \then\; (\C; \C_1) \; \elsesym \; (\C; \C_2)$
\item[b)] $(\ifsym \; \B \; \then\; \C_1 \; \elsesym \; \C_2); (\ifsym \; \B \; \then \; \C_3 \; \elsesym \; \C_4)$ and $\ifsym \; \B \; \then\; (\C_1;\C_3) \; \elsesym \; (\C_2;\C_4)$
\end{enumerate}

equivalent with respect to the state transition semantics $[[\cdot]]$?
}

\question{
\item[2.3] Show that the following program computes the greatest common divisor of two positive integers $x,y$:

\begin{align*}
& \whilesym \; \notsym(x = y) \; \dosym \\
& \;\;\;\;\; \whilesym \; (x < y) \; \dosym \; y := y - x; \\
& \;\;\;\;\; \whilesym \; (y < x) \; \dosym \; x := x - y
\end{align*}

Here we write $\E_1 < \E_2$ for $\E_1 \leq \E_2 \; \andsym \; \notsym(\E_1 = \E_2)$ and $\E_1 - \E_2$ for $\E_1 + \negation(\E_2)$. 
What are the values of the above program under the input/output and termination semantics? 
How do your answers change if we instead consider the program

\begin{align*}
& \whilesym \; \notsym(x = y) \; \dosym \\
& \;\;\;\;\; \whilesym \; {\color{red} (x \leq y)} \; \dosym \; y := y - x; \\
& \;\;\;\;\; \whilesym \; {\color{red} (y \leq x)} \; \dosym \; x := x - y
\end{align*}
}

\end{enumerate}

\end{document}


